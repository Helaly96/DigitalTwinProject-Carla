# -*- coding: utf-8 -*-
"""FMU_Final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1SdWZKP6f--_-_DXVNT0DZLqMxBdk2vuB
"""

from fmpy import read_model_description, extract, dump
from fmpy.fmi2 import FMU2Slave
import numpy as np
import matplotlib.pyplot as plt
import shutil

class ABSSimulator:
    def __init__(self, fmu_path, step_size=0.01):
        """
        Initialize the ABS FMU simulator

        Args:
            fmu_path (str): Path to the ABS FMU file
            step_size (float): Simulation step size in seconds
        """
        self.fmu_filename = fmu_path
        self.step_size = step_size
        self.start_time = 0.0
        self.time = self.start_time
        self.rows = []

        # Load and extract FMU
        dump(self.fmu_filename)
        self.model_description = read_model_description(self.fmu_filename)
        self.unzipdir = extract(self.fmu_filename)

        # Create value reference dictionary
        self.vrs = {var.name: var.valueReference for var in self.model_description.modelVariables}

        # Get variables by causality
        self.parameters = [v for v in self.model_description.modelVariables if v.causality == 'parameter']
        self.inputs = [v for v in self.model_description.modelVariables if v.causality == 'input']
        self.outputs = [v for v in self.model_description.modelVariables if v.causality == 'output']

        # Instantiate FMU
        self.fmu = FMU2Slave(
            guid=self.model_description.guid,
            unzipDirectory=self.unzipdir,
            modelIdentifier=self.model_description.coSimulation.modelIdentifier,
            instanceName='abs_instance'
        )

        # Initialize FMU
        self.fmu.instantiate()
        #self.fmu.setupExperiment(startTime=self.start_time)
        self.fmu.setupExperiment(startTime=0, stopTime=10.0)
        self.fmu.enterInitializationMode()

        # Set default parameters (from model description)
        self.set_parameters({
            'Rr': 1.25,       # Wheel radius
            'ctrl': 1,        # Control parameter
            'g': 32.18,       # Gravity
            'm': 50,           # Mass
            # Mu (friction) parameters
            **{f'mu[1,{i}]': val for i, val in enumerate([
                0, 0.4, 0.8, 0.97, 1, 0.98, 0.96, 0.94, 0.92, 0.9,
                0.88, 0.855, 0.83, 0.81, 0.79, 0.77, 0.75, 0.73, 0.72, 0.71, 0.7
            ], start=1)},
            # Slip parameters
            **{f'slip[1,{i}]': val for i, val in enumerate([0, 0.05, 0.1], start=1)}
        })

        # Verify desired_slip input exists (critical for control)
        self.desired_slip_vr = None
        for var in self.inputs:
            if 'desired_slip' in var.name.lower():
                self.desired_slip_vr = var.valueReference
                break

        if self.desired_slip_vr is None:
            raise ValueError("FMU missing 'desired_slip' input. Re-export from Simulink with Inport block.")

        self.fmu.exitInitializationMode()


    def set_parameters(self, parameters):
        """
        Set model parameters

        Args:
            parameters (dict): Dictionary of parameter names and values
        """
        for name, value in parameters.items():
            if name in self.vrs:
                self.fmu.setReal([self.vrs[name]], [value])

    def step(self, desired_slip=None):
        """
        Perform one simulation step

        Args:
            brake_pressure (float): Brake pressure input (0-1)
        """
        # Set inputs (only brake pressure in this model)
       # Set desired slip if provided
        if desired_slip is not None and self.desired_slip_vr is not None:
            self.fmu.setReal([self.desired_slip_vr], [desired_slip])

        # Perform simulation step
        self.fmu.doStep(
            currentCommunicationPoint=self.time,
            communicationStepSize=self.step_size
        )

        # Get and store results
        #results = {'time': self.time}

        # Store inputs
        #for var in self.inputs:
            #results[var.name] = self.fmu.getReal([var.valueReference])[0]

        # Store outputs
        outputs = {
            'time':self.time,
            'desired_slip' : desired_slip if desired_slip is not None else float('nan'),
            **{var.name: self.fmu.getReal([var.valueReference])[0] for var in self.outputs}
        }

        self.rows.append(outputs)
        self.time += self.step_size

    def terminate(self):
        """Clean up FMU resources"""
        self.fmu.terminate()
        self.fmu.freeInstance()
        shutil.rmtree(self.unzipdir, ignore_errors=True)

    def plot_results(self):
        """Plot simulation results"""
        if not self.rows:
            print("No results to plot")
            return

        # Create figure
        times = [r['time'] for r in self.rows]
        plt.figure(figsize=(16, 8))

        # Plot wheel speed and vehicle speed (typical ABS outputs)
        plt.subplot(2, 2, 1)
        if 'Ww' in self.rows[0]:
            plt.plot(times, [r['Ww'] for r in self.rows], label='Wheel Speed (rad/sec.)')
        if 'Vs' in self.rows[0]:
            plt.plot(times, [r['Vs'] for r in self.rows], label='Vehicle Speed (m/sec.)')
        plt.xlabel('Time (s)')
        plt.ylabel('Speed')
        plt.title('Speed Comparison')
        plt.legend()
        plt.grid(True)

        # Plot Current SLip
        plt.subplot(2, 2, 2)
        if 'desired_slip' in self.rows[0]:
            plt.plot(times, [r['desired_slip'] for r in self.rows], label='Desired Slip (Input)')
            plt.xlabel('Time (s)')
            plt.ylabel('Desired Slip')
            plt.title('Desired Slip (Input)')
            plt.grid(True)

        # Plot slip ratio
        plt.subplot(2, 2, 3)
        if 'slp' in self.rows[0]:
            plt.plot(times, [r['slp'] for r in self.rows], label='Actual Slip')
        if 'desired_slip' in self.rows[0]:
            plt.plot(times, [r['desired_slip'] for r in self.rows], label='Desired Slip')
            plt.xlabel('Time (s)')
            plt.ylabel('Slip Ratio')
            plt.title('Slip Comparison')
            plt.grid(True)

        # Plot friction coefficient
        plt.subplot(2, 2, 4)
        if 'Wa' in self.rows[0]:
            plt.plot(times, [r['Wa'] for r in self.rows])
            plt.xlabel('Time (s)')
            plt.ylabel('Wheel Acceleration')
            plt.title('Wheel Acceleration')
            plt.grid(True)

        plt.tight_layout()
        plt.show()

def simulate_abs_braking(fmu_path, step_size, total_time):
    """
    Run complete ABS braking simulation

    Args:
        fmu_path (str): Path to ABS FMU
        brake_profile (list): List of brake pressure values (0-1) for each step
        step_size (float): Simulation step size

    Returns:
        list: Simulation results
    """
    simulator = ABSSimulator(fmu_path, step_size)
    # Right after initialization, check available outputs
    print("Available outputs:", [var.name for var in simulator.outputs])
    print("Input variables:", [var.name for var in simulator.inputs])
    print("Time values:", [r['time'] for r in simulator.rows[:5]])

    # Define desired slip profile (example: ramp from 0.1 to 0.3)
    def get_desired_slip(t):
        return 0.1 + 0.02 * t  # Linear ramp

    # Simulation loop
    while simulator.time < total_time:
        current_slip = get_desired_slip(simulator.time)
        simulator.step(desired_slip=current_slip)

        # Optional: Print progress
        #if simulator.time % 1.0 < step_size:  # Every ~1 second
            #print(f"t={simulator.time:.1f}s, Desired Slip={current_slip:.3f}")


    simulator.plot_results()
    results = simulator.rows
    simulator.terminate()

    return results

# Example usage
if __name__ == "__main__":
    # Create a brake pressure profile (sudden brake application)
    step_size = 0.01
    total_duration = 15
    time_steps = int(total_duration/step_size)


    # Run simulation
    results = simulate_abs_braking(
        fmu_path='F:/IIOT/FMU/sldemo_absbrake101.fmu',
        #brake_profile=brake_profile,
        step_size=step_size,
        total_time=total_duration
    )
